use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
mod affix;
mod error;
use error::DictionaryBuildError;

use crate::dict::affix::DictAffix;

#[derive(Debug)]
pub struct Dictionary {
    words: fst::Set<Vec<u8>>,
}

impl Dictionary {
    pub fn try_build_from_path(
        dict: &PathBuf,
        affix: &PathBuf,
    ) -> Result<Self, DictionaryBuildError> {
        let dict_file = File::open(dict).map_err(DictionaryBuildError::OpeningFile)?;
        let dict_reader = BufReader::new(dict_file);

        let affix_file = File::open(affix).map_err(DictionaryBuildError::OpeningFile)?;
        let affix_reader = BufReader::new(affix_file);

        Dictionary::try_build(dict_reader, affix_reader)
    }
    //Flags example
    // retricoter/a0p+
    // retriever/S.
    // rétroactivement/L'D'Q'
    // A flag is separated by a non char
    fn apply_rule(word: &str, affix: &DictAffix, flags: &str) -> impl Iterator<Item = String> {
        let mut results = Vec::new();
        let mut buffer = String::new();

        for ch in flags.chars() {
            if ch.is_ascii_alphabetic() {
                buffer.push(ch);
            } else {
                buffer.push(ch);

                results.extend(affix.apply_rules(word, &buffer));
                buffer.clear();
            }
        }

        if !buffer.is_empty() {
            results.extend(affix.apply_rules(word, &buffer));
        }

        results.into_iter()
    }

    pub fn try_build<T>(reader_dict: T, reader_affix: T) -> Result<Self, DictionaryBuildError>
    where
        T: BufRead,
    {
        let affix = affix::DictAffix::try_build(reader_affix)?;
        let mut lines = reader_dict.lines();
        //The words should be already sorted by the dictionary
        let number_words = lines
            .next()
            .transpose()?
            .unwrap_or_default()
            .parse::<usize>()
            .map_err(DictionaryBuildError::InvalidFormatNoCount)?;

        let mut words: Vec<String> = Vec::with_capacity(number_words);
        for line in lines.map_while(Result::ok).filter(|line| !line.is_empty()) {
            let mut split = line.split('/');
            let word = split.next().unwrap_or_default();
            if word.is_empty() {
                continue;
            }
            words.push(word.to_string());

            if let Some(flags) = split.next() {
                let vec: Vec<String> = Dictionary::apply_rule(word, &affix, flags).collect();
                words.extend(Dictionary::apply_rule(word, &affix, flags));
            }
        }
        words.sort();

        let set = fst::Set::from_iter(words).map_err(DictionaryBuildError::WordsIterator)?;

        Ok(Self { words: set })
    }

    pub fn check_word(&self, word: &str) -> bool {
        self.words.contains(word)
    }
}

#[cfg(test)]
mod dict_tests {
    use super::*;
    use std::io::BufReader;

    #[test]
    fn test_dictionary_build_basic() {
        let dict_data = "\
3
walk/D
run
recover/U";

        let affix_data = "\
SFX D 0 ed .
PFX U re pre .";

        let dict = Dictionary::try_build(
            BufReader::new(dict_data.as_bytes()),
            BufReader::new(affix_data.as_bytes()),
        )
        .unwrap();

        // Base words
        assert!(dict.check_word("walk"));
        assert!(dict.check_word("run"));
        assert!(dict.check_word("recover"));
        // Generated by suffix rule D
        assert!(dict.check_word("walked"));

        // Generated by prefix rule U
        assert!(dict.check_word("precover"));

        // Negative cases
        assert!(!dict.check_word("walkingly"));
        assert!(!dict.check_word("rewalk"));
    }

    #[test]
    fn test_dictionary_handles_multiple_flags() {
        let dict_data = "\
1
walking/D";

        let affix_data = "\
SFX D ing ed .";

        let dict = Dictionary::try_build(
            BufReader::new(dict_data.as_bytes()),
            BufReader::new(affix_data.as_bytes()),
        )
        .unwrap();

        assert!(dict.check_word("walked"));
        assert!(dict.check_word("walking"));
        assert!(!dict.check_word("walker"));
    }

    #[test]
    fn test_flags_with_non_alpha_separators() {
        let dict_data = "\
    1
rétroactivement/L'D'Q'";

        let affix_data = "\
SFX L ment ment .
SFX D ments ment .
SFX Q ment ment .";

        let dict = Dictionary::try_build(
            BufReader::new(dict_data.as_bytes()),
            BufReader::new(affix_data.as_bytes()),
        )
        .unwrap();
        // Base word must be present
        assert!(dict.check_word("rétroactivement"));

        // No derived word is produced because flags in the .dic contain an apostrophe,
        // while affix rules are defined for "L", "D", "Q" (no apostrophe).
        assert!(!dict.check_word("rétroactive"));
    }
}
